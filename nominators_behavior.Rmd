---
title: "Nominators' Behavior"
author: "Jonas Gehrlein @ Web3 Foundation"
date: 20/04/2023
output: html_document
version: "1.0"
---


```{r setup, fig.width=4, fig.height=3, warning=FALSE, message=FALSE, echo=FALSE}
# Load the required R packages:
library(dplyr)
library(rmarkdown)
library(ggplot2)
library(reshape2)
library(tidyverse)
library(scales)
library(dbplyr)
library(assert)
library(ineq)
library(splitstackshape)
library(polkadotutils)
library(data.table)
library(googleCloudStorageR)
library(bigrquery)
library(httr)
library(bit64)
```


```{r, echo = FALSE}
# Set the OAuth scopes
options(bigrquery.oauth.scopes = c("https://www.googleapis.com/auth/cloud-platform"))
bigrquery::bq_auth(email = "jonas@web3.foundation", cache = TRUE)

# Authenticate googleCloudStorageR using the token obtained by bigrquery
gcs_auth(token = bq_token())
```

```{r, message=FALSE, echo = FALSE}
# User Input
# Can be "polkadot" or "kusama"
chain = "polkadot"

# if we want not every session but every `time_offset` session Using "1" means we include all sessions. Using "2" would mean every second session etc. Since 6 sessions is one day, we can basically determine the days with 6*DAYS.
time_offset <- 6*7
# The amount of tables that should be downloaded
number_tables <- 37*6
# The sessions to analyze.
last_session = 9406
first_session = last_session - time_offset * number_tables

difference = last_session - first_session 
#x = c(last_session:(last_session - difference))
sessions = c(first_session:(first_session + difference))
# extract every time_offset's value
sessions <- sessions[seq(1, length(sessions), time_offset)]
old <- Sys.time() # get start time
missing_tables <- 0
```

```{r, echo=FALSE}
# Parameters to determine whether a change in bonded amount was due to auto-compound or an active choice. Here, we pretend that an increase by bonded_amount * APY / 365 is a compound. I.e., if the change from old to new balance is less than that, we pretend its not an active choice. Making APY higher increases the range where we pretend it was an auto compound.
APY <- 0.18
number_session_per_era <- 6  # Payout happens every 6 sessions
payout_periods <- ceiling(time_offset / number_session_per_era)  # How many payout periods are covered by time_offset
threshold <- 1 + payout_periods * (APY / 365)
```

```{r, echo=FALSE}
initiate_data <- function(df_t0, df_t1, threshold) {
  # Full outer join between df_t0 and df_t1 by stash_address
  merged_df <- merge(df_t0, df_t1, by = "stash_address", all = TRUE, suffixes = c("_t0", "_t1"))

  # Initialize the session_count based on whether session_t0 and session_t1 exist
  merged_df$session_count <- ifelse(is.na(merged_df$session_t0) & !is.na(merged_df$session_t1), 1,
                               ifelse(!is.na(merged_df$stash_address) & is.na(merged_df$session_t1), 1, 2))
  
  # Vectorized logic to identify targets_changed
  merged_df$targets_changed <- mapply(function(t0, t1, s0, s1, df_t1_session) {
    if (is.na(s0) && !is.na(s1)) {
      return(list(s1))
    } else if (!is.na(s0) && is.na(s1)) {
      return(list(c(s0, df_t1_session)))
    } else if (!is.na(t0) && t0 != t1) {
      return(list(c(s0, s1)))
    } else {
      return(list(s0))
    }
  }, merged_df$targets_t0, merged_df$targets_t1, merged_df$session_t0, merged_df$session_t1, MoreArgs = list(df_t1$session[1]))

  # Vectorized logic to identify bonded_amount_changed
  merged_df$bonded_amount_changed <- mapply(function(b0, b1, s0, s1, df_t1_session) {
    if (is.na(s0) && !is.na(s1)) {
      return(list(s1))  # New entry, track the new session
    } else if (!is.na(s0) && is.na(s1)) {
      return(list(c(s0, df_t1_session)))  # Old entry dropped, track the session
    } else if (!is.na(b0) && b1 > b0) {
      if (b1 > b0 * threshold) {
        return(list(c(s0, s1)))  # Trigger change if the increase exceeds the threshold
      } else {
        return(list(s0))  # No significant change
      }
    } else if (!is.na(b0) && b1 < b0) {
      return(list(c(s0, s1)))  # Balance decreased, track the session
    } else {
      return(list(s0))  # No change
    }
  }, 
  merged_df$bonded_amount_t0, 
  merged_df$bonded_amount_t1, 
  merged_df$session_t0, 
  merged_df$session_t1, 
  MoreArgs = list(df_t1$session[1])
)

  # Create the final data frame
  final_df <- data.frame(
    stash_address = merged_df$stash_address,
    targets = ifelse(is.na(merged_df$session_t1), NA, 
                     ifelse(is.na(merged_df$targets_t1), merged_df$targets_t0, merged_df$targets_t1)),
    bonded_amount = ifelse(is.na(merged_df$session_t1), NA, 
                           ifelse(is.na(merged_df$bonded_amount_t1), merged_df$bonded_amount_t0, merged_df$bonded_amount_t1)),
    targets_changed = I(merged_df$targets_changed),
    bonded_amount_changed = I(merged_df$bonded_amount_changed),
    session_count = merged_df$session_count,
    session = merged_df$session_t1
  )

  return(final_df)
}
```

```{r, echo = FALSE}
update_data <- function(initial_data, new_data, threshold) {
  # Ensure that stash_address is unique in both data sets
  initial_data <- initial_data[!duplicated(initial_data$stash_address), ]
  new_data <- new_data[!duplicated(new_data$stash_address), ]

  # Full outer join (all = TRUE) to retain all nominators
  merged_df <- merge(initial_data, new_data, by = "stash_address", all = TRUE, suffixes = c("_old", "_new"))

  # Vectorized update of targets_changed
  merged_df$targets_changed <- mapply(function(t_old, t_new, s_old, s_new, changed_list, new_session) {
    if (!is.na(s_old) && !is.na(s_new)) {
      if (t_old != t_new) {
        if (!(s_new %in% changed_list)) {
          return(append(changed_list, s_new))  # Add session if target changed
        } else {
          return(changed_list)
        }
      } else {
        return(changed_list)
      }
    } else if (is.na(s_old) && !is.na(s_new)) {
      return(c(s_new))  # New session entry
    } else if (!is.na(s_old) && is.na(s_new)) {
      return(append(changed_list, new_session))  # Old session entry dropped
    } else {
      return(changed_list)
    }
  }, merged_df$targets_old, merged_df$targets_new, merged_df$session_old, merged_df$session_new, merged_df$targets_changed, MoreArgs = list(new_data$session[1]))

  # Vectorized update of bonded_amount_changed
  merged_df$bonded_amount_changed <- mapply(function(b_old, b_new, s_old, s_new, changed_list, new_session) {
    if (!is.na(s_old) && !is.na(s_new)) {
      if (b_new > b_old * threshold) {
        if (!(s_new %in% changed_list)) {
          return(append(changed_list, s_new))  # Trigger change if balance increased and exceeded threshold
        } else {
          return(changed_list)
        }
      } else if (b_new < b_old) {
        if (!(s_new %in% changed_list)) {
          return(append(changed_list, s_new))  # Trigger change if balance decreased
        } else {
          return(changed_list)
        }
      } else {
        return(changed_list)  # No significant change
      }
    } else if (is.na(s_old) && !is.na(s_new)) {
      return(c(s_new))  # New session entry
    } else if (!is.na(s_old) && is.na(s_new)) {
      return(append(changed_list, new_session))  # Old session entry dropped
    } else {
      return(changed_list)
    }
  }, merged_df$bonded_amount_old, merged_df$bonded_amount_new, merged_df$session_old, merged_df$session_new, merged_df$bonded_amount_changed, MoreArgs = list(new_data$session[1]))

  # Update the session count
  merged_df$session_count <- ifelse(!is.na(merged_df$session_old) & !is.na(merged_df$session_new),
                                    merged_df$session_count + 1,
                                    ifelse(is.na(merged_df$session_old) & !is.na(merged_df$session_new), 1, merged_df$session_count))

  # Create the final data frame
  final_df <- data.frame(
    stash_address = merged_df$stash_address,
    targets = ifelse(is.na(merged_df$session_new), merged_df$targets_old, merged_df$targets_new),
    bonded_amount = ifelse(is.na(merged_df$session_new), merged_df$bonded_amount_old, merged_df$bonded_amount_new),
    targets_changed = I(merged_df$targets_changed),
    bonded_amount_changed = I(merged_df$bonded_amount_changed),
    session_count = merged_df$session_count,
    session = merged_df$session_new,
    stringsAsFactors = FALSE
  )

  return(final_df)
}
``` 

```{r, echo = FALSE}
# This function takes in the validator data table and extracts information of each validator about their "stakers". The stakers variable is formatted as a separated list of stash_address of the nominator that is allocated to them as a staker and the bonded_amount that this nominator got allocated to that validator. This function makes a new data set for every nominator in that list and their bonded_amount and keeps the info about the validator stash address this entry is coming from.
extract_stakers_and_bonded <- function(stakers) {
  # Split the string by semicolons
  stakers_split <- strsplit(stakers, split = "[;,]")[[1]]
  
  # Check if the length of stakers_split is valid (must be an even number)
  if (length(stakers_split) < 2) {
    # Return empty data frame if there's not enough data
    return(data.frame(stash_address = character(0), bonded_amount = numeric(0), stringsAsFactors = FALSE))
  }
  
  # Extract the stash addresses (every first element) and bonded amounts (every second element)
  stash_addresses <- stakers_split[seq(1, length(stakers_split), 2)]  # Every first element is a stash address
  bonded_amounts <- as.numeric(stakers_split[seq(2, length(stakers_split), 2)])  # Every second element is a bonded amount
  
  # Return a data frame with stash addresses and bonded amounts
  return(data.frame(stash_address = stash_addresses, bonded_amount = bonded_amounts, stringsAsFactors = FALSE))
}

# Modified filter_nominators function
filter_nominators <- function(input_df) {

  # Apply the function to extract stakers and bonded amounts from the stakers column
  stakers_list <- lapply(input_df$stakers, extract_stakers_and_bonded)

  # Create a data frame of validators and their corresponding nominators with bonded amounts
  validator_stakers <- bind_rows(
    Map(function(staker_df, validator_address) {
      # Only add non-empty staker data frames
      if (nrow(staker_df) > 0) {
        staker_df$validator_address <- validator_address
        return(staker_df)
      } else {
        return(NULL)
      }
    }, stakers_list, input_df$stash_address)
  )

  return(validator_stakers)
}
```

```{r, echo = FALSE}
calculate_days_since_change <- function(overall_nominators, session_timestamps) {
  # Get the timestamp of the most recent session as the reference
  latest_session <- max(as.numeric(names(session_timestamps)))
  reference_timestamp <- session_timestamps[[as.character(latest_session)]]

  # Calculate days since last bonded amount change
  overall_nominators$days_since_bonded_amount_changed <- sapply(overall_nominators$bonded_amount_changed, function(changed_list) {
    # Find the highest session in the bonded_amount_changed list
    if (length(changed_list) > 0) {
      last_change_session <- max(unlist(changed_list))
      # Look up the timestamp of the highest session
      last_change_timestamp <- session_timestamps[[as.character(last_change_session)]]
      if (!is.null(last_change_timestamp)) {
        # Calculate the difference in days between the last change timestamp and the reference timestamp
        as.numeric(difftime(as.POSIXct(reference_timestamp, origin = "1970-01-01", tz = "UTC"), 
                            as.POSIXct(last_change_timestamp, origin = "1970-01-01", tz = "UTC"), 
                            units = "days"))
      } else {
        return(NA)
      }
    } else {
      return(NA)
    }
  })

  # Calculate days since last target change
  overall_nominators$days_since_target_changed <- sapply(overall_nominators$targets_changed, function(changed_list) {
    # Find the highest session in the targets_changed list
    if (length(changed_list) > 0) {
      last_change_session <- max(unlist(changed_list))
      # Look up the timestamp of the highest session
      last_change_timestamp <- session_timestamps[[as.character(last_change_session)]]
      if (!is.null(last_change_timestamp)) {
        # Calculate the difference in days between the last change timestamp and the reference timestamp
        as.numeric(difftime(as.POSIXct(reference_timestamp, origin = "1970-01-01", tz = "UTC"), 
                            as.POSIXct(last_change_timestamp, origin = "1970-01-01", tz = "UTC"), 
                            units = "days"))
      } else {
        return(NA)
      }
    } else {
      return(NA)
    }
  })

  return(overall_nominators)
}
```

```{r, echo=FALSE}
# Getting the first nominators data set to start the process
nominators_t0 <- getStakingDataNew("nominators", "session", sessions[1], chain, "online", TRUE)

# Getting the newest validator information (which we need later)
validator_newest <- polkadotutils::getStakingDataNew("validators", "session", last_session, chain, "online", TRUE)
# Collect some garbage
gc()

# We'll keep the timestamps of the different sessions in the future to be able to calculate when they last interacted (in days)
session_timestamps <- list()

# Manually add the first session timestamp from nominators_t0
session_timestamps[[as.character(nominators_t0$session[1])]] <- nominators_t0$timestamp[1] / 1000  # Convert from milliseconds to seconds
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
for (i in 2:length(sessions)) {
  message(paste0("Processing session: ", sessions[i]))
  
  # Try to download the next session's nominator data
  nominators_next <- tryCatch(
    {
      getStakingDataNew("nominators", "session", sessions[i], chain, "online", TRUE)
    },
    error = function(e) {
      message(paste("Error in session", sessions[i], "- skipping. Error message:", e$message))
      missing_tables <<- missing_tables + 1  # Increment the missing tables counter
      return(NULL)  # Return NULL to indicate failure
    }
  )
  
  # Skip this iteration if nominators_next is NULL (data couldn't be downloaded)
  if (is.null(nominators_next)) {
    next
  }
  session_timestamps[[as.character(nominators_next$session[1])]] <- nominators_next$timestamp[1] / 1000  # Convert from milliseconds to seconds

  # If we are in the second iteration, initialize the data
  if (i == 2) {
    overall_nominators <- initiate_data(nominators_t0, nominators_next, threshold)
  } else {
    overall_nominators <- update_data(overall_nominators, nominators_next, threshold)
  }
  
  # Save intermediate results to avoid excessive memory usage
  if (i %% 10 == 0) {
    saveRDS(overall_nominators, file = paste0("overall_nominators_session_", i, ".rds"))
    message(paste("Saved intermediate results at session", i))
  }
  
  # Explicitly call garbage collection to free memory
  gc()
  
  if(i == length(sessions)){
    nominators_newest <- nominators_next
  }

  # Remove intermediate data
  rm(nominators_next)
}

# Remove some expensive columns that are not needed.
overall_nominators <- overall_nominators %>%
  select(-targets)

# Print elapsed time of data collection
new <- Sys.time() - old 
print(new)
```

```{r, echo = FALSE}
# Add information about the last change (both in bonded_amount and targets) based on the "newest" session they did a change relative to the newest session timestamp.
overall_nominators <- calculate_days_since_change(overall_nominators, session_timestamps)

# Add an indicator to the full list of all nominators ever present of which are the current nominators.
overall_nominators <- overall_nominators %>%
  mutate(current_set = if_else(stash_address %in% nominators_newest$stash_address, 1, 0))
```

```{r, echo=FALSE}
# Here we count the number of sessions in the list of changes that we made.
for(i in 1:nrow(overall_nominators)){
  overall_nominators$nr_amount_changed[i] <- length(overall_nominators$bonded_amount_changed[i][[1]])
}
for(i in 1:nrow(overall_nominators)){
  overall_nominators$nr_targets_changed[i] <- length(overall_nominators$targets_changed[i][[1]])
}

overall_nominators$total_changes <- overall_nominators$nr_amount_changed + overall_nominators$nr_targets_changed
```

```{r echo = FALSE}
# Here we calculate how often a change occured per session.

## Analysis Targets Change
# Create a dataframe that unnests the list of sessions per nominator and aggregates the number of changes on session level
targets_changed_per_session <- overall_nominators %>%
  select(stash_address, targets_changed) %>%
  unnest(cols = targets_changed)
targets_changed_per_session$tracker <- 1
targets_changed_per_session_aggregated <- aggregate(targets_changed_per_session$tracker, by = list(targets_changed_per_session$targets_changed), FUN = sum)
colnames(targets_changed_per_session_aggregated) <- c("session", "number_changes")

# There are a few missing tables which means that changes "aggregate" over a longer period of time until a new data set is found and then all the changes are accounted to that new session. To smoothen this out, I take the average change per session if there are missing tables. 
for(i in 1:nrow(targets_changed_per_session_aggregated)){
  if(i == 1){
    targets_changed_per_session_aggregated$distance[i] <- 1
  } else {
    targets_changed_per_session_aggregated$distance[i] <- targets_changed_per_session_aggregated$session[i] - targets_changed_per_session_aggregated$session[i-1]
  }
}
targets_changed_per_session_aggregated$average_nr_changes <- targets_changed_per_session_aggregated$number_changes / targets_changed_per_session_aggregated$distance
# The percentage of changes in the targets of a nominator. Since we count the first appearance of a nominator as a change in target, we substract it here. And since this is session data, a reasonable time frame to change something would be once per era at maximum. 
overall_nominators$targets_changed_percent <- (overall_nominators$nr_targets_changed - 1) / (overall_nominators$session_count/number_session_per_era)

# Analysis Bonded Amount Change
bonded_changed_per_session <- overall_nominators %>%
  select(stash_address, bonded_amount_changed) %>%
  unnest(cols = bonded_amount_changed)

bonded_changed_per_session$tracker <- 1
bonded_changed_per_session_aggregated <- aggregate(bonded_changed_per_session$tracker, by = list(bonded_changed_per_session$bonded_amount_changed), FUN = sum)
colnames(bonded_changed_per_session_aggregated) <- c("session", "number_changes")

for(i in 1:nrow(bonded_changed_per_session_aggregated)){
  if(i == 1){
    bonded_changed_per_session_aggregated$distance[i] <- 1
  } else {
    bonded_changed_per_session_aggregated$distance[i] <- bonded_changed_per_session_aggregated$session[i] - bonded_changed_per_session_aggregated$session[i-1]
  }
}
bonded_changed_per_session_aggregated$average_nr_changes <- bonded_changed_per_session_aggregated$number_changes / bonded_changed_per_session_aggregated$distance
# The percentage of changes in the bonds of a nominator. Since we count the first appearance of a nominator as a change in bonds, we subtract it here. And since this is session data, a reasonable time frame to change something would be once per era at maximum. 
overall_nominators$bonded_changed_percent <- (overall_nominators$nr_amount_changed - 1) / (overall_nominators$session_count/number_session_per_era)
```


```{r, echo = FALSE}
# Here, we calculate take the information about the staleness of the nominators and cross-reference it with their validators to understand how much backing of a validator is composed of different levels of staleness of nominations.

# We extract the stakers of every validator and span them out into a new data set where each of these stakers have their own row. We keep a column with their validator, bonded amount and their own stash address
validator_stakers_filtered <- filter_nominators(validator_newest)
validator_stakers_filtered$bonded_amount <- normalize(validator_stakers_filtered$bonded_amount, "p")

overall_nominators_active <- overall_nominators %>%
  filter(current_set == 1)

# We now merge the previous data set with the staleness data we obtained before
validator_nominators_merged <- validator_stakers_filtered %>%
  left_join(overall_nominators_active[, c("stash_address", "days_since_target_changed")], 
            by = "stash_address")
# Keep only the relevant columns for analysis
validator_nominators_staleness <- validator_nominators_merged %>%
  select(validator_address, stash_address, bonded_amount, days_since_target_changed)


validator_nominators_extended <- validator_nominators_staleness %>%
  left_join(validator_newest[, c("stash_address", "total_stake", "commission_percent", "num_voters", "self_stake")], 
            by = c("validator_address" = "stash_address"))

rm(validator_nominators_staleness, validator_nominators_merged)

validator_nominators_extended <- validator_nominators_extended %>%
  mutate(nominator_stake = total_stake - self_stake) %>%
  filter(commission_percent < 100)

# Step 2: Calculate the stake proportion of each nominator relative to the validator's total nominator stake
validator_nominators_extended <- validator_nominators_extended %>%
  mutate(stake_proportion = bonded_amount / nominator_stake)

# Step 3: Calculate the weighted days since last target change (weighted by the nominator's stake proportion)
validator_nominators_extended <- validator_nominators_extended %>%
  mutate(weighted_days_since_change = round(stake_proportion * days_since_target_changed, 0))

# Step 4: Compute the weighted average of days since last change for each validator
validator_staleness_summary <- validator_nominators_extended %>%
  group_by(validator_address) %>%
  summarise(weighted_avg_days_since_change = sum(weighted_days_since_change, na.rm = TRUE))
```

```{r, echo = FALSE}
# Step 1: Compute the density using the density function
density_data <- density(validator_staleness_summary$weighted_avg_days_since_change, na.rm = TRUE)

# Step 2: Filter the density data for values greater than 180
density_above_180 <- density_data$x[density_data$x > 180]  # Get values of x greater than 180
density_values_above_180 <- density_data$y[density_data$x > 180]  # Corresponding density values

# Step 3: Calculate the area under the curve for values greater than 180
total_density_above_180 <- sum(density_values_above_180) * (density_data$x[2] - density_data$x[1])  # Trapezoidal integration

# Display the result
total_density_above_180

ggplot(validator_staleness_summary, aes(x = weighted_avg_days_since_change)) +
  geom_density(fill = "blue", alpha = 0.4) +
  labs(title = "Density Plot of Weighted Average Days Since Change", 
       x = "Weighted Average Days Since Change") +
  theme_minimal()
```

# Introduction

This analysis gives insights into the behavior of nominators within the `r chain` network. Nominators are tracked across consecutive sessions using their unique stash address. The main motivation for this analysis is to get an understanding about how often nominators are updating their targets, i.e., make a new selection of validators, and understand how much backing of validators comes from these different types of nominators. The main outcome for the analysis is the days that have passed since a nominator last updated their targets.

The following table illustrates the parameters of the analysis. Note, that there have been some outages in the data collection, but the analysis copes with that and minimizes the impact on the outcome quality.
<table style="border-collapse:collapse;border-spacing:0" class="tg"><thead><tr><th style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">Parameter</th><th style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">Value</th></tr></thead><tbody><tr><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">Chain</td><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">`r chain`</td></tr><tr><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">First Session</td><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">`r first_session`</td></tr><tr><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">Last Session</td><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">`r last_session`</td></tr><tr><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">Missing Tables</td><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal"><span style="color:#905;background-color:#ddd">`r missing_tables`</span></td></tr><tr><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">Total number of unique nominators</td><td style="border-color:inherit;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal"><span style="color:#905;background-color:#ddd">`r nrow(overall_nominators)`</span></td></tr></tbody></table>

# Changes over time
In this section, we examine the temporal fluctuations in both the bonded amount and the targets chosen by each nominator. This analysis helps to identify trends and patterns in the behavior of nominators over time.

### Bonded Amount: Histogram of changes

The analysis primarily emphasizes the frequency of alterations in the bonded amount. It is essential to note that changes only take effect following a new election, which occurs every `r number_session_per_era` sessions. To account for this, it is more meaningful to normalize the frequency on a "per era" basis rather than per session. In this context, if a nominator modifies their bonded amount once throughout `r number_session_per_era` sessions, the frequency in the histogram is represented as 1. Conversely, if a nominator adjusts their bonded_amount every session, the frequency is denoted as 6.

```{r, echo = FALSE}
# Create histogram with ggplot2
ggplot(overall_nominators, aes(x = bonded_changed_percent)) +
  geom_histogram(binwidth = 1, color = "black", fill = "lightblue") +
  labs(title = "Histogram of Bonded Amount Changed Percentage",
       x = "Bonded Amount Changed Percentage", y = "Frequency")
```

There are a few outlier nominators who adjust their bonded amount with remarkable frequency. For the purpose of this analysis, we will concentrate on those with a frequency lying between 0 and 1, ensuring a more representative understanding of typical nominator behavior.

```{r, echo = FALSE}
# Create histogram with ggplot2
ggplot(subset(overall_nominators, bonded_changed_percent <= 1), aes(x = bonded_changed_percent)) +
  geom_histogram(binwidth = 0.1, color = "black", fill = "lightblue") +
  labs(title = "Histogram of Bonded Amount Changed Percentage",
       x = "Bonded Amount Changed Percentage", y = "Frequency")
```

### Bonded amount: Changes over sessions

The subsequent graph illustrates the variations in bonded amount across sessions. The frequency displayed is in absolute terms, representing the total number of nominators who altered their bonded_amount within each individual session. This visualization helps to convey the overall trends and patterns in nominators' behavior over time.

```{r, echo = FALSE}
ggplot(subset(bonded_changed_per_session_aggregated, session != first_session), aes(x = session, y = average_nr_changes)) +
  geom_line() +
  geom_point(size = 0.5) +
  theme_minimal() +
  labs(title = "Number of Changes Over Time (Bonded Amount Change)",
       x = "Session",
       y = "Number of Changes") +
  theme(panel.grid.minor = element_blank())
```

We can observe a high number of changes in the bonded amount. However, this is primarily due to many nominators employing automatic re-bonding of staking rewards. Distinguishing manual changes in the bonded amount from automatic ones is challenging. An approximation could be made based on the stash address size and the expected staking rewards per session, but this is left unexplored for now.

## Targets
This analysis forms the most crucial aspect of nominator behavior as it directly sheds light on their validator preferences and the frequency with which they update their nominations. The following histogram displays individual changes in targets across nominators over the entire time frame. The data is normalized by the number of sessions a nominator has been active and is presented on a per-era basis. In other words, a value of 1 signifies that a nominator altered their targets once every six sessions they were active. It is important to note that, in contrast to the `bonded_amount`, changes in targets are always manually initiated by nominators, reflecting conscious decision-making.

### Targets: Histogram of changes

```{r, echo = FALSE}
# Create histogram with ggplot2
ggplot(overall_nominators, aes(x = targets_changed_percent)) +
  geom_histogram(binwidth = 1, color = "black", fill = "lightblue") +
  labs(title = "Histogram of Targets Changed Percentage",
       x = "Targets Changed Percentage", y = "Frequency")
```

Once more, we encounter some outlier nominators who alter their targets with exceptional frequency, which hampers the graph's readability. To address this, the following graph narrows its focus to nominators who modify their targets between 0 and 100% of the time, specifically every six sessions. This refined visualization aids in better understanding the typical behavior of nominators in relation to their target changes.

```{r, echo = FALSE}
# Create histogram with ggplot2
ggplot(subset(overall_nominators, targets_changed_percent <= 1), aes(x = targets_changed_percent)) +
  geom_histogram(binwidth = 0.1, color = "black", fill = "lightblue") +
  labs(title = "Histogram of Targets Changed Percentage",
       x = "Targets Changed Percentage", y = "Frequency")
```

The following graph plots the frequency of target changes of nominators per session.

```{r, echo = FALSE}
ggplot(subset(targets_changed_per_session_aggregated, session != first_session), aes(x = session, y = average_nr_changes)) +
  geom_line() +
  geom_point(size = 0.5) +
  theme_minimal() +
  labs(title = "Number of Changes Over Time (Targets Change)",
       x = "Session",
       y = "Number of Changes") +
  theme(panel.grid.minor = element_blank())
```



# Nomination of inactive validators

```{r, echo = FALSE}
# Unnest the targets column for each nominator and create a new data frame that has a row for each entry in "targets".
nominators_unnested <- subset(nominators_newest, select = c("stash_address", "targets")) %>%
    separate_rows(targets, sep = ",")

colnames(nominators_unnested) <- c("nominator_stash", "stash_address")

merged <- merge(nominators_unnested, subset(validator_newest, select = c("stash_address", "active")), by = "stash_address", all = TRUE)
merged$counter <- 1

merged_aggregated <- aggregate(cbind(active, counter) ~ nominator_stash, data = merged, FUN = sum, na.rm = TRUE)

merged_aggregated$ratio <- merged_aggregated$active / merged_aggregated$counter
merged_aggregated$at_least_one_inactive <- ifelse(merged_aggregated$ratio < 1, 1,0)
  
```

The subsequent histogram presents the ratio of active to inactive validators within the nominators' targets. Unlike previous analyses, this examination focuses on the current state of the network during the most recent session (`r last_session`). In this context, a ratio of 1 indicates that all validators a nominator is voting for are presently active. This insight offers an understanding of the overall alignment of nominator preferences with the active validator pool.

```{r, echo=FALSE}
ggplot(merged_aggregated, aes(x = ratio)) +
  geom_histogram(binwidth = 0.1, color = "black", fill = "lightblue") +
  labs(title = "Histogram of ratio of nominations of active validators",
       x = "Ratio of nominations of active validators", y = "Frequency")
```

In general, there are `r format(sum(merged_aggregated$at_least_one_inactive), scientific = FALSE)` (or `r round(sum(merged_aggregated$at_least_one_inactive) / nrow(merged_aggregated)*100, digits=2)`%) nominators that have at least one inactive validator in their targets.
